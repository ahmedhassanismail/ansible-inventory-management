pipeline {
    agent any
    
    parameters {
        string(name: 'PATCH_NUMBER', defaultValue: '35247514', description: 'Patch identification number (e.g., 35247514)')
        string(name: 'PATCH_FILE', defaultValue: 'p35247514_122130_Generic.zip', description: 'Patch ZIP file name')
        string(name: 'ORACLE_HOME', defaultValue: 'E:\\Oracle\\Middleware\\Oracle_Home', description: 'Oracle Home directory path on Windows server')
        string(name: 'PATCH_LOCAL_PATH', defaultValue: '/home/appadmin/patches/p35247514_122130_Generic.zip', description: 'Source patch file path on Ansible server')
        string(name: 'PATCH_REMOTE_PATH', defaultValue: 'E:\\Oracle\\patches\\p35247514_122130_Generic.zip', description: 'Destination patch file path on Windows server')
        string(name: 'PATCH_EXTRACT_PATH', defaultValue: 'E:\\Oracle\\Middleware\\patches\\35247514', description: 'Patch extraction directory on Windows server')
        choice(name: 'TARGET_HOSTS', choices: ['prod_weblogic_win', 'prod_weblogic_medgo', 'prod_weblogic_batch', 'prod_weblogic_external_reports'], description: 'Target host group from inventory')
        booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Run in check mode (dry run) - preview changes without making them')
        booleanParam(name: 'VERBOSE', defaultValue: true, description: 'Enable verbose output for detailed logging')
        booleanParam(name: 'HOST_BY_HOST', defaultValue: true, description: 'Execute host by host with user confirmation for each host')
    }
    
    stages {
        stage('Validate Parameters') {
            steps {
                script {
                    // Validate required parameters
                    def requiredParams = [
                        'PATCH_NUMBER', 'PATCH_FILE', 'ORACLE_HOME', 
                        'PATCH_LOCAL_PATH', 'PATCH_REMOTE_PATH', 'PATCH_EXTRACT_PATH'
                    ]
                    
                    requiredParams.each { param ->
                        if (!params[param]?.trim()) {
                            error "Parameter ${param} is required! Please provide a value."
                        }
                    }
                    
                    echo "‚úÖ All required parameters provided:"
                    requiredParams.each { param ->
                        echo "   ${param}: ${params[param]}"
                    }
                }
            }
        }
        
        stage('Pre-Execution Summary') {
            steps {
                script {
                    echo """
                    ===== PRE-EXECUTION SUMMARY =====
                    üéØ Target Environment: PROD
                    üîß Patch Number: ${params.PATCH_NUMBER}
                    üì¶ Patch File: ${params.PATCH_FILE}
                    üñ•Ô∏è  Target Hosts: ${params.TARGET_HOSTS}
                    üè† Oracle Home: ${params.ORACLE_HOME}
                    üìÅ Source Path: ${params.PATCH_LOCAL_PATH}
                    üíæ Remote Path: ${params.PATCH_REMOTE_PATH}
                    üìÇ Extract Path: ${params.PATCH_EXTRACT_PATH}
                    üîç Dry Run Mode (TEST MODE): ${params.DRY_RUN ? 'ENABLED' : 'DISABLED'}
                    üìä Verbose Output: ${params.VERBOSE ? 'ENABLED' : 'DISABLED'}
                    üö¶ Host-by-Host Execution: ${params.HOST_BY_HOST ? 'ENABLED' : 'DISABLED'}
                    =================================
                    """
                }
            }
        }
        
        stage('Get Host List') {
            steps {
                script {
                    // Get the list of hosts in the target group
                    def hostList = sh(
                        script: "ansible -i inventory ${params.TARGET_HOSTS} --list-hosts",
                        returnStdout: true
                    ).trim()
                    
                    // Parse the host list (remove group name and clean up)
                    def hosts = hostList.split('\n').findAll { it.trim() && !it.contains('hosts') }.collect { it.trim() }
                    
                    echo "üìã Hosts in group '${params.TARGET_HOSTS}':"
                    hosts.eachWithIndex { host, index ->
                        echo "   ${index + 1}. ${host}"
                    }
                    
                    // Store hosts in environment variable for other stages
                    env.HOST_LIST = hosts.join(',')
                    env.TOTAL_HOSTS = hosts.size().toString()
                    env.CURRENT_HOST_INDEX = '0'
                    
                    echo "üöÄ Total hosts to process: ${env.TOTAL_HOSTS}"
                }
            }
        }
        
        stage('Execute WebLogic Patch - Host by Host') {
            when {
                expression { params.HOST_BY_HOST == true }
            }
            steps {
                script {
                    def hosts = env.HOST_LIST.split(',')
                    def totalHosts = hosts.size()
                    
                    echo "üîÑ Starting host-by-host execution for ${totalHosts} hosts..."
                    
                    hosts.eachWithIndex { host, index ->
                        def currentHostIndex = index + 1
                        env.CURRENT_HOST_INDEX = currentHostIndex.toString()
                        
                        echo """
                        ===== PROCESSING HOST ${currentHostIndex}/${totalHosts} =====
                        üñ•Ô∏è  Target Host: ${host}
                        üìç Progress: ${currentHostIndex}/${totalHosts}
                        üîß Patch Number: ${params.PATCH_NUMBER}
                        üì¶ Patch File: ${params.PATCH_FILE}
                        ‚è∞ Start Time: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
                        =========================================
                        """
                        
                        // User confirmation for each host (except first one)
                        if (currentHostIndex > 1) {
                            input message: "Ready to proceed with host ${currentHostIndex}/${totalHosts}: ${host}?", 
                                  ok: "Proceed with ${host}"
                        }
                        
                        // Execute patch application for current host
                        def checkMode = params.DRY_RUN ? '--check' : ''
                        def verboseFlag = params.VERBOSE ? '-vv' : ''
                        
                        def ansibleCmd = """
                            ansible-playbook -i inventory Apply_Patch_weblogic.yml \\
                              -e "patch_number='${params.PATCH_NUMBER}'" \\
                              -e "patch_file='${params.PATCH_FILE}'" \\
                              -e "oracle_home='${params.ORACLE_HOME}'" \\
                              -e "patch_local_path='${params.PATCH_LOCAL_PATH}'" \\
                              -e "patch_remote_path='${params.PATCH_REMOTE_PATH}'" \\
                              -e "patch_extract_path='${params.PATCH_EXTRACT_PATH}'" \\
                              --limit ${host} \\
                              ${checkMode} \\
                              ${verboseFlag}
                        """.stripIndent()
                        
                        echo "üöÄ Executing patch application for ${host}:"
                        echo ansibleCmd
                        
                        try {
                            sh ansibleCmd
                            echo "‚úÖ Patch application completed successfully for ${host}"
                        } catch (Exception e) {
                            echo "‚ùå Patch application failed for ${host}"
                            echo "Error: ${e.getMessage()}"
                            
                            // Ask user if they want to continue with next host
                            if (currentHostIndex < totalHosts) {
                                def continueExecution = input message: "Patch application failed for ${host}. Do you want to continue with the next host?", 
                                                           ok: "Continue with next host", 
                                                           submitter: "Continue", 
                                                           submitterParameter: "continue"
                                
                                if (continueExecution != "continue") {
                                    error "Execution stopped by user after failure on ${host}"
                                }
                            } else {
                                error "Patch application failed for the last host: ${host}"
                            }
                        }
                        
                        // Show progress
                        echo """
                        ===== HOST ${currentHostIndex}/${totalHostS} COMPLETED =====
                        üñ•Ô∏è  Host: ${host}
                        üìç Progress: ${currentHostIndex}/${totalHosts}
                        üîß Patch Number: ${params.PATCH_NUMBER}
                        üì¶ Patch File: ${params.PATCH_FILE}
                        ‚è∞ Completion Time: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
                        =========================================
                        """
                        
                        // Pause between hosts (except for the last one)
                        if (currentHostIndex < totalHosts) {
                            echo "‚è∏Ô∏è  Pausing before next host..."
                            sleep 5
                        }
                    }
                    
                    echo "üéâ All hosts processed successfully!"
                }
            }
        }
        
        stage('Execute WebLogic Patch - All Hosts') {
            when {
                expression { params.HOST_BY_HOST == false }
            }
            steps {
                script {
                    echo "üöÄ Executing patch application for all hosts in parallel..."
                    
                    def checkMode = params.DRY_RUN ? '--check' : ''
                    def verboseFlag = params.VERBOSE ? '-vv' : ''
                    
                    def ansibleCmd = """
                        ansible-playbook -i inventory Apply_Patch_weblogic.yml \\
                          -e "patch_number='${params.PATCH_NUMBER}'" \\
                          -e "patch_file='${params.PATCH_FILE}'" \\
                          -e "oracle_home='${params.ORACLE_HOME}'" \\
                          -e "patch_local_path='${params.PATCH_LOCAL_PATH}'" \\
                          -e "patch_remote_path='${params.PATCH_REMOTE_PATH}'" \\
                          -e "patch_extract_path='${params.PATCH_EXTRACT_PATH}'" \\
                          --limit ${params.TARGET_HOSTS} \\
                          ${checkMode} \\
                          ${verboseFlag}
                    """.stripIndent()
                    
                    echo "üöÄ Executing Ansible command:"
                    echo ansibleCmd
                    
                    if (params.DRY_RUN) {
                        echo "‚ö†Ô∏è  DRY RUN MODE: No actual changes will be made!"
                        echo "üìã This will show what would happen without applying the patch"
                    }
                    
                    sh ansibleCmd
                }
            }
        }
        
        stage('Post-Execution Summary') {
            steps {
                script {
                    def executionStatus = params.DRY_RUN ? "DRY RUN COMPLETED" : "WEBLOGIC PATCH APPLIED"
                    def executionMode = params.HOST_BY_HOST ? "Host-by-Host" : "All Hosts Parallel"
                    
                    echo """
                    ===== ${executionStatus} =====
                    üîß Patch Number: ${params.PATCH_NUMBER}
                    üì¶ Patch File: ${params.PATCH_FILE}
                    üñ•Ô∏è  Target Hosts: ${params.TARGET_HOSTS}
                    üè† Oracle Home: ${params.ORACLE_HOME}
                    üìÅ Source Path: ${params.PATCH_LOCAL_PATH}
                    üíæ Remote Path: ${params.PATCH_REMOTE_PATH}
                    üìÇ Extract Path: ${params.PATCH_EXTRACT_PATH}
                    üö¶ Execution Mode: ${executionMode}
                    üìä Total Hosts Processed: ${env.TOTAL_HOSTS ?: 'N/A'}
                    ‚è∞ Execution Time: ${new Date().format("yyyy-MM-dd HH:mm:ss")}
                    =========================================
                    """
                }
            }
        }
    }
    
    post {
        always {
            echo "üèÅ WebLogic patch pipeline completed"
            echo "üìä Final Status:"
            echo "   - Total Hosts: ${env.TOTAL_HOSTS ?: 'N/A'}"
            echo "   - Execution Mode: ${params.HOST_BY_HOST ? 'Host-by-Host' : 'All Hosts Parallel'}"
            echo "   - Dry Run: ${params.DRY_RUN ? 'Yes' : 'No'}"
        }
        success {
            if (params.DRY_RUN) {
                echo "‚úÖ WebLogic patch dry run completed successfully!"
                echo "üìã Review the output above to see what would happen during patch application"
                echo "üîÑ To apply the actual patch, run the pipeline again with DRY_RUN=false"
            } else {
                echo "‚úÖ WebLogic patch applied successfully!"
                echo "üîß Patch ${params.PATCH_NUMBER} has been applied to ${params.TARGET_HOSTS}"
                echo "üì¶ Patch file ${params.PATCH_FILE} was processed"
                echo "üåê WebLogic has been updated with the new patch"
                
                if (params.HOST_BY_HOST) {
                    echo "üö¶ Host-by-host execution completed with user control"
                }
            }
        }
        failure {
            echo "‚ùå WebLogic patch application failed!"
            echo "üîç Check the console output above for error details"
            echo "üìã Verify all parameters are correct"
            echo "üñ•Ô∏è  Ensure target hosts are accessible"
            echo "üì¶ Check if patch file exists at ${params.PATCH_LOCAL_PATH}"
            echo "üè† Verify Oracle Home path: ${params.ORACLE_HOME}"
            
            if (params.HOST_BY_HOST) {
                echo "üö¶ Host-by-host execution was interrupted"
                echo "üìä Progress: ${env.CURRENT_HOST_INDEX ?: 'Unknown'}/${env.TOTAL_HOSTS ?: 'Unknown'} hosts completed"
            }
        }
    }
}
